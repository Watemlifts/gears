"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var events = require("events");
var watch_1 = require("./watch");
var Debounce = (function () {
    function Debounce(delay) {
        this.delay = delay;
        this.handle = undefined;
    }
    Debounce.prototype.set = function (func) {
        var _this = this;
        if (this.handle !== undefined) {
            clearTimeout(this.handle);
        }
        this.handle = setTimeout(function () {
            func();
            _this.handle = undefined;
        }, this.delay);
    };
    return Debounce;
}());
var Watcher = (function (_super) {
    __extends(Watcher, _super);
    function Watcher(path, timeout) {
        var _this = _super.call(this) || this;
        _this.path = path;
        _this.timeout = timeout;
        _this.state = "pending";
        _this.watcher = null;
        _this.debounce = new Debounce(20);
        return _this;
    }
    Watcher.prototype.start = function () {
        var _this = this;
        switch (this.state) {
            case "pending": {
                this.state = "started";
                var options = { recursive: true };
                this.watcher = watch_1.watch(this.path, options, function (event, filename) {
                    _this.debounce.set(function () { return _this.emit("data", [event, filename]); });
                });
                break;
            }
            default:
                this.emit("error", "cannot start a watcher more than once");
                this.dispose();
                break;
        }
    };
    Watcher.prototype.dispose = function () {
        switch (this.state) {
            case "pending":
                this.state = "stopped";
                this.emit("end");
                break;
            case "started":
                this.state = "stopped";
                this.watcher.removeAllListeners();
                this.watcher.close();
                this.emit("end");
                break;
            case "stopped":
                break;
        }
    };
    return Watcher;
}(events.EventEmitter));
function create_watcher(path, timeout) {
    return new Watcher(path, timeout);
}
exports.create_watcher = create_watcher;
