"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function extract_input(argv) {
    var process = argv.shift();
    var script = argv.shift();
    var line = argv.join(' ');
    return line;
}
function validate_input(input) {
    var l = 0;
    for (var n = 0; n < input.length; n++) {
        var ch = input.charAt(n);
        switch (ch) {
            case '[':
                l += 1;
                break;
            case ']':
                l -= 1;
                break;
        }
    }
    return (l === 0);
}
function extract_paths(input) {
    var buf = [];
    for (var n = 0; n < input.length; n++) {
        var ch = input.charAt(n);
        if (ch == '[') {
            break;
        }
        else {
            buf.push(input.charAt(n));
        }
    }
    var paths = buf.join('').trim();
    paths = paths.length > 0 ? paths : "./";
    return paths.split(' ').map(function (seg) { return seg.trim(); });
}
function extract_commands(input) {
    var buf = [];
    var cur = [];
    var l = 0;
    for (var n = 0; n < input.length; n++) {
        var ch = input.charAt(n);
        switch (ch) {
            case '[': {
                if (l > 0)
                    cur.push(ch);
                l += 1;
                break;
            }
            case ']': {
                l -= 1;
                if (l > 0)
                    cur.push(ch);
                if (l == 0) {
                    buf.push(cur.join(''));
                    cur = [];
                }
                break;
            }
            default: {
                if (l > 0)
                    cur.push(ch);
                break;
            }
        }
    }
    return buf;
}
function parse_argument(argv) {
    var input = extract_input(argv);
    if (validate_input(input) === false)
        throw Error("invalid argument");
    return {
        paths: extract_paths(input),
        commands: extract_commands(input),
        timeout: 2000
    };
}
exports.parse_argument = parse_argument;
