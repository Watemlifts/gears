"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var events = require("events");
var readline = require("readline");
var watcher_1 = require("../watcher/watcher");
var process_1 = require("../process/process");
var Runtime = (function (_super) {
    __extends(Runtime, _super);
    function Runtime(argument, writer) {
        var _this = _super.call(this) || this;
        _this.argument = argument;
        _this.writer = writer;
        _this.state = "pending";
        _this.watchers = [];
        _this.processes = [];
        _this.readline = readline.createInterface({ input: process.stdin });
        _this.readline.on("line", function (data) {
            _this.processes.forEach(function (process) {
                return process.write(data);
            });
        });
        return _this;
    }
    Runtime.prototype.restart = function () {
        var _this = this;
        this.processes.forEach(function (process) { return process.dispose(); });
        this.processes = this.argument.commands.map(function (command, index) {
            return process_1.create_process(index, command);
        });
        this.processes.forEach(function (proc, index) {
            _this.writer.info("[" + index + ": " + proc.shell() + "]");
            proc.on("data", function (data) { return _this.writer.write(data[1]); });
            proc.on("end", function () { return _this.writer.info("[" + index + ": end]"); });
            proc.start();
        });
    };
    Runtime.prototype.start = function () {
        var _this = this;
        switch (this.state) {
            case "pending":
                this.state = "started";
                this.restart();
                this.watchers = this.argument.paths.map(function (path) {
                    var watcher = watcher_1.create_watcher(path, _this.argument.timeout);
                    watcher.on("data", function () { return _this.restart(); });
                    watcher.on("error", function () { });
                    watcher.on("end", function () { });
                    watcher.start();
                    return watcher;
                });
                break;
            default:
                this.emit("error", "a runtime can only be started once.");
                this.dispose();
                break;
        }
    };
    Runtime.prototype.dispose = function () {
        switch (this.state) {
            case "pending":
                this.state = "stopped";
                this.emit("end");
                break;
            case "started":
                this.state = "stopped";
                this.processes.forEach(function (process) { return process.dispose(); });
                this.watchers.forEach(function (watcher) { return watcher.dispose(); });
                this.emit("end");
                break;
            case "stopped":
                break;
        }
    };
    return Runtime;
}(events.EventEmitter));
function create_runtime(argument, writer) {
    return new Runtime(argument, writer);
}
exports.create_runtime = create_runtime;
