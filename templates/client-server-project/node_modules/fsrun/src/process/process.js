"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var events = require("events");
var cp = require("child_process");
var Process = (function (_super) {
    __extends(Process, _super);
    function Process(id, command) {
        var _this = _super.call(this) || this;
        _this.id = id;
        _this.command = command;
        _this.state = "pending";
        _this.encoding = "utf8";
        _this.child = undefined;
        _this.windows = /^win/.test(process.platform);
        return _this;
    }
    Process.prototype.shell = function () {
        return this.command;
    };
    Process.prototype.write = function (data) {
        switch (this.state) {
            case "started":
                this.child.stdin.write(data + "\n");
                break;
            default:
                break;
        }
    };
    Process.prototype.start = function () {
        var _this = this;
        var extract = function (command) {
            var parts = command.split(" ");
            if (parts.length === 0) {
                return {
                    app: "echo",
                    args: ["nothing", "to", "run"]
                };
            }
            else {
                var command_1 = parts.shift();
                return {
                    app: command_1,
                    args: parts
                };
            }
        };
        var emit_data = function (data) {
            if (_this.state === "started") {
                _this.emit("data", [_this.id, data]);
            }
        };
        switch (this.state) {
            case "pending":
                this.state = "started";
                if (this.windows) {
                    this.child = cp.spawn("cmd", ["/c", this.command]);
                }
                else {
                    var _command = extract(this.command);
                    this.child = cp.spawn(_command.app, _command.args);
                }
                this.child.stdout.setEncoding(this.encoding);
                this.child.stderr.setEncoding(this.encoding);
                this.child.stdout.on("data", function (data) { return emit_data(data); });
                this.child.stderr.on("data", function (data) { return emit_data(data); });
                this.child.on("close", function () { return _this.dispose(); });
                break;
            default:
                this.emit("error", "cannot start a process more than once.");
                this.dispose();
                break;
        }
    };
    Process.prototype.dispose = function () {
        switch (this.state) {
            case "pending":
                this.state = "stopped";
                this.emit("end");
                break;
            case "started":
                this.state = "stopped";
                if (this.windows === true) {
                    this.child.stdout.removeAllListeners();
                    this.child.stderr.removeAllListeners();
                    this.child.removeAllListeners();
                    cp.exec('taskkill /pid ' + this.child.pid + ' /T /F');
                }
                else {
                    this.child.stdout.removeAllListeners();
                    this.child.stderr.removeAllListeners();
                    this.child.removeAllListeners();
                    this.child.stdout.pause();
                    this.child.stderr.pause();
                    this.child.stdin.end();
                    this.child.kill("SIGINT");
                }
                this.emit("end");
                break;
            case "stopped":
                break;
        }
    };
    return Process;
}(events.EventEmitter));
function create_process(id, shell) {
    return new Process(id, shell);
}
exports.create_process = create_process;
