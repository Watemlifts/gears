"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var events = require("events");
var fs = require("fs");
var http = require("http");
var sys = require("../sys/sys");
var uuid = require("./uuid");
var mime = require("./mime");
var assets = require("./assets");
var resourceInfo = function (path, callback) {
    fs.stat(path, function (error, stat) {
        if (error) {
            callback({
                path: path,
                type: "notfound",
                mime: mime.lookup(path)
            });
        }
        else {
            callback({
                path: path,
                type: stat.isDirectory() ? "directory" : "file",
                mime: mime.lookup(path)
            });
        }
    });
};
var Server = (function (_super) {
    __extends(Server, _super);
    function Server(options) {
        var _this = _super.call(this) || this;
        _this.options = options;
        _this.state = "pending";
        _this.server = undefined;
        _this.clients = {};
        _this.ping_handle = undefined;
        return _this;
    }
    Server.prototype.start = function () {
        var _this = this;
        switch (this.state) {
            case "pending":
                this.state = "started";
                this.server = http.createServer(function (req, res) { return _this.handler(req, res); });
                this.server.listen(this.options.port);
                this.ping_handle = setInterval(function () { return _this.handlePing(); }, 5000);
                break;
            default:
                this.emit("error", "a server can only be started once.");
                this.dispose();
                break;
        }
    };
    Server.prototype.reload = function () {
        var _this = this;
        switch (this.state) {
            case "started":
                Object.keys(this.clients).forEach(function (key) {
                    _this.clients[key].write("reload");
                });
                break;
            default:
                break;
        }
    };
    Server.prototype.dispose = function () {
        switch (this.state) {
            case "pending":
                this.state = "stopped";
                this.emit("end");
                break;
            case "started":
                this.state = "stopped";
                clearInterval(this.ping_handle);
                this.server.close();
                this.emit("end");
                break;
            case "stopped":
                break;
        }
    };
    Server.prototype.handlePing = function () {
        var _this = this;
        switch (this.state) {
            case "started":
                Object.keys(this.clients).forEach(function (key) {
                    _this.clients[key].write("ping");
                });
                break;
            default:
                break;
        }
    };
    Server.prototype.handle404 = function (request, response, path) {
        response.writeHead(404, { "Content-Type": "text/plain" });
        response.write("404 not found");
        response.end();
    };
    Server.prototype.handle403 = function (request, response, path) {
        response.writeHead(403, { "Content-Type": "text/plain" });
        response.write("403 forbidden");
        response.end();
    };
    Server.prototype.handleHtmlDocument = function (request, response, path, contentType) {
        response.writeHead(200, { "Content-Type": contentType });
        fs.readFile(path, "utf8", function (error, content) {
            var script = '<script type="text/javascript" src="./__reload"></script>';
            content = [content, script].join("\n");
            response.end(content, "utf-8");
        });
    };
    Server.prototype.handleFileAsset = function (request, response, path, contentType) {
        response.writeHead(200, { "Content-Type": contentType });
        var readstream = fs.createReadStream(path);
        readstream.pipe(response);
    };
    Server.prototype.handleReloadScript = function (request, response) {
        response.writeHead(200, { "Content-Type": "text/javascript" });
        response.write(assets.reload_script());
        response.end();
    };
    Server.prototype.handleSignalClient = function (request, response) {
        var _this = this;
        response.setHeader('Connection', "Transfer-Encoding");
        response.setHeader('Content-Type', "text/html; charset=utf-8");
        response.setHeader('Transfer-Encoding', "chunked");
        response.setHeader("Cache-Control", "no-cache, no-store, must-revalidate");
        response.setHeader("Pragma", "no-cache");
        response.setHeader("Expires", "0");
        response.statusCode = 200;
        response.write("established");
        var id = uuid.u4();
        this.clients[id] = response;
        request.connection.on("close", function () {
            delete _this.clients[id];
        });
    };
    Server.prototype.handleStatic = function (request, response) {
        var _this = this;
        resourceInfo(sys.resolve_uri_path(this.options.path, request.url), function (info) {
            switch (info.type) {
                case "notfound":
                    _this.handle404(request, response, info.path);
                    break;
                case "directory":
                    _this.handle403(request, response, info.path);
                    break;
                case "file":
                    switch (info.mime) {
                        case "text/html":
                            _this.handleHtmlDocument(request, response, info.path, info.mime);
                            break;
                        default:
                            _this.handleFileAsset(request, response, info.path, info.mime);
                            break;
                    }
                    break;
            }
        });
    };
    Server.prototype.handler = function (request, response) {
        switch (request.url) {
            case "/__signal":
                this.handleSignalClient(request, response);
                break;
            case "/__reload":
                this.handleReloadScript(request, response);
                break;
            default:
                this.emit("request", { url: request.url, method: request.method });
                this.handleStatic(request, response);
                break;
        }
    };
    return Server;
}(events.EventEmitter));
function create_server(options) {
    return new Server(options);
}
exports.create_server = create_server;
