"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var events = require("events");
var watcher_1 = require("../watcher/watcher");
var server_1 = require("../server/server");
var Runtime = (function (_super) {
    __extends(Runtime, _super);
    function Runtime(argument, writer) {
        var _this = _super.call(this) || this;
        _this.argument = argument;
        _this.writer = writer;
        _this.state = "pending";
        _this.watcher = undefined;
        _this.server = undefined;
        return _this;
    }
    Runtime.prototype.start = function () {
        var _this = this;
        switch (this.state) {
            case "pending":
                this.state = "started";
                this.server = server_1.create_server({
                    path: this.argument.path,
                    port: this.argument.port
                });
                this.server.on("request", function (request) {
                    _this.writer.write(request.method + " " + request.url + "\n");
                });
                this.server.start();
                this.watcher = watcher_1.create_watcher(this.argument.path, this.argument.timeout);
                this.watcher.on("data", function () {
                    _this.writer.info("[reload]");
                    _this.server.reload();
                });
                this.watcher.on("error", function () { });
                this.watcher.on("end", function () { });
                this.watcher.start();
                break;
            default:
                this.emit("error", "a runtime can only be started once.");
                this.dispose();
                break;
        }
    };
    Runtime.prototype.dispose = function () {
        switch (this.state) {
            case "pending":
                this.state = "stopped";
                this.emit("end");
                break;
            case "started":
                this.state = "stopped";
                this.server.dispose();
                this.watcher.dispose();
                this.emit("end");
                break;
            case "stopped":
                break;
        }
    };
    return Runtime;
}(events.EventEmitter));
function create_runtime(argument, writer) {
    return new Runtime(argument, writer);
}
exports.create_runtime = create_runtime;
