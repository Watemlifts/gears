"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var fs = require("fs");
var path = require("path");
var os = require("os");
var LinuxWatcher = (function () {
    function LinuxWatcher(watchers) {
        this.watchers = watchers;
    }
    LinuxWatcher.prototype.addListener = function (event, listener) {
        this.watchers.forEach(function (watcher) { return watcher.addListener(event, listener); });
        return this;
    };
    LinuxWatcher.prototype.removeListener = function (event, listener) {
        this.watchers.forEach(function (watcher) { return watcher.addListener(event, listener); });
        return this;
    };
    LinuxWatcher.prototype.removeAllListeners = function (event) {
        this.watchers.forEach(function (watcher) { return watcher.removeAllListeners(); });
        return this;
    };
    LinuxWatcher.prototype.on = function (event, listener) {
        this.watchers.forEach(function (watcher) { return watcher.on(event, listener); });
        return this;
    };
    LinuxWatcher.prototype.once = function (event, listener) {
        this.watchers.forEach(function (watcher) { return watcher.once(event, listener); });
        return this;
    };
    LinuxWatcher.prototype.prependListener = function (event, listener) {
        this.watchers.forEach(function (watcher) { return watcher.prependListener(event, listener); });
        return this;
    };
    LinuxWatcher.prototype.prependOnceListener = function (event, listener) {
        this.watchers.forEach(function (watcher) { return watcher.prependOnceListener(event, listener); });
        return this;
    };
    LinuxWatcher.prototype.setMaxListeners = function (n) {
        this.watchers.forEach(function (watcher) { return watcher.setMaxListeners(n); });
        return this;
    };
    LinuxWatcher.prototype.getMaxListeners = function () {
        return (this.watchers.length === 0) ? 0 : this.watchers[0].getMaxListeners();
    };
    LinuxWatcher.prototype.listeners = function (event) {
        return (this.watchers.length === 0) ? [] : this.watchers[0].listeners(event);
    };
    LinuxWatcher.prototype.emit = function (event) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        return false;
    };
    LinuxWatcher.prototype.eventNames = function () {
        return (this.watchers.length === 0) ? [] : this.watchers[0].eventNames();
    };
    LinuxWatcher.prototype.listenerCount = function (type) {
        return (this.watchers.length === 0) ? 0 : this.watchers[0].listenerCount(type);
    };
    LinuxWatcher.prototype.close = function () {
        this.watchers.forEach(function (watcher) { return watcher.close(); });
    };
    return LinuxWatcher;
}());
exports.LinuxWatcher = LinuxWatcher;
var directoryWatchList = function (directoryPath, buffer) {
    if (buffer === void 0) { buffer = []; }
    buffer.push(directoryPath);
    var contents = fs.readdirSync(directoryPath);
    var records = contents.map(function (content) { return ({
        path: path.join(directoryPath, content),
        stat: fs.statSync(path.join(directoryPath, content))
    }); }).filter(function (record) { return record.stat.isDirectory(); });
    records.forEach(function (record) { return directoryWatchList(record.path, buffer); });
    return buffer;
};
exports.watch = function (filePath, options, listener) {
    if (os.platform() !== "linux") {
        return fs.watch(filePath, options, listener);
    }
    else {
        options.encoding = options.encoding || "utf8";
        options.persistent = options.persistent || true;
        options.recursive = options.recursive || false;
        var stat = fs.statSync(filePath);
        if (stat.isFile()) {
            return fs.watch(filePath, options, listener);
        }
        else if (stat.isDirectory()) {
            if (!options.recursive) {
                return fs.watch(filePath, options, listener);
            }
            else {
                var directories = directoryWatchList(filePath);
                var watchers = directories.map(function (directory) { return fs.watch(directory, options, listener); });
                return new LinuxWatcher(watchers);
            }
        }
        else {
            throw Error("not a file or directory.");
        }
    }
};
